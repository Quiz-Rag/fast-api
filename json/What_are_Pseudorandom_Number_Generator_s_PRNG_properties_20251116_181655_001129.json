{
  "timestamp": "2025-11-16T18:16:55.001256",
  "question": "What are Pseudorandom Number Generator s (PRNG) properties?",
  "search_query": "What are Pseudorandom Number Generator s PRNG properties What are Pseudorandom Number Generator s (PRNG) properties? What is symmetric encryption? What are the five ingredients?",
  "retrieved_documents_count": 3,
  "documents": [
    {
      "chunk_number": 1,
      "content": "Combining sources of randomness•Suppose r1, r2, …, rkare random numbers from different sources. E.g.,r1 = electrical noise from a resistor or semiconductorr2 = sample of hip-hop music on radior3 = clock on computerb = r1⊕r2⊕…⊕rkIf any one of r1, r2, …, rkis truly random, then so is bMany poor sources + 1 good source = good entropy\n\nPseudorandom Number Generators (PRNGs)•True randomness is expensive•Pseudorandom number generator(PRNGs): An algorithm that uses a little bit of true randomness to generate a lot of random-looking output•Also called deterministic random bit generators(DRBGs)•PRNGs are deterministic: Output is generated according to a set algorithm•However, for an attacker who can’t see the internal state, the output is computationally indistinguishablefrom true randomness\n\nPRNG: Definition•A PRNG has two functions:•PRNG.Seed(randomness): Initializes the internal state using the entropy•Input: Some truly random bits•PRNG.Generate(n): Generate npseudorandom bits•Input: A number s•Output: npseudorandom bits•Updates the internal state as needed•Properties•Correctness: Deterministic•Efficiency: Efficient to generate pseudorandom bits•Security: Indistinguishability from random•Rollback resistance: cannot deduce anything about any previously-generated bit",
      "content_length": 1279,
      "metadata": {
        "chunk_index": 0,
        "slide_number": 9,
        "document_type": "pdf",
        "collection_name": "batch_1763296567",
        "source_file": "Lecture 9_slides.pdf"
      },
      "citation": {
        "source_file": "Lecture 9_slides.pdf",
        "document_type": "pdf",
        "slide_number": 9,
        "collection": "batch_1763296567",
        "formatted": "Slide 9"
      },
      "human_readable_label": "Slide 9"
    },
    {
      "chunk_number": 2,
      "content": "PRNGs: Summary•True randomness requires sampling a physical process•PRNG: An algorithm that uses a little bit of true randomness to generate a lot of random-looking output•Seed(entropy): Initialize internal state•Generate(n): Generate n bits of pseudorandom output•Security: computationally indistinguishable from truly random bits\n\nStream Ciphers\n\nStream Ciphers•process the message bit by bit (as a stream) •typically have a (pseudo) random stream key•combined (XOR) with plaintext bit by bit •randomness of stream keycompletely destroysany statistically properties in the message •Ci= MiXOR StreamKeyi•what could be simpler!!!! •but must never reuse stream key•otherwise, can remove effect and recover messages, M⨁K⨁K = M\n\nStream Cipher Properties•some design considerations are:•statistically random •depends on large enough key•large linear complexity•correlation immunity •confusion•diffusion\n\nHow to generate Stream Key?•How to generate Stream Key?\n\nStream Ciphers •Idea: replace “rand” by “pseudo rand”•Use Pseudo Random Number Generator •A secure PRNG produces output that looks indistinguishable from random•An attacker who can’t see the internal PRNG state can’t learn any output•PRNG: {0,1}s®{0,1}n•expand a short (e.g., 128-bit) random seed into a long (typically unbounded) string that “looks random”•Secret key is the seed•Basic encryption method: Ekey[M] = M ÅPRNG(key)",
      "content_length": 1385,
      "metadata": {
        "slide_number": 9,
        "source_file": "Lecture 9_slides.pdf",
        "collection_name": "batch_1763296567",
        "chunk_index": 2,
        "document_type": "pdf"
      },
      "citation": {
        "source_file": "Lecture 9_slides.pdf",
        "document_type": "pdf",
        "slide_number": 9,
        "collection": "batch_1763296567",
        "formatted": "Slide 9"
      },
      "human_readable_label": "Slide 9"
    },
    {
      "chunk_number": 3,
      "content": "Example construction of PRNG•Using block cipher in Counter (CTR) mode:•If you want m random bits, and a block cipher with Ekhas n bits, apply the block cipher m/n times and concatenate the result:•PRNG.Seed(K | IV) = Ek(IV, 1) | Ek(IV, 2) | Ek(IV, 3) … Ek(IV, ceil(m/n)),•| is concatenation•Initialization vector (IV)/Nonce–typically is random or pseudorandom\nRandomness, PRNG output\n\nPRNG: Security•Can we design a PRNG that is truly random?•A PRNG cannot be truly random•The output is deterministic given the initial seed•A secure PRNG is computationally indistinguishable from random to an attacker•Game: Present an attacker with a truly random sequence and a sequence outputted from a secure PRNG•An attacker should be able to determine which is which with probability ≈0•Equivalence: An attacker cannot predict future output of the PRNG\n\nCreate pseudorandom numbers•Truly random numbers are impossible with any program!•However, we can generate seemingly random numbers, called pseudorandom numbers•The function rand() returns a non-negative number between 0 and RAND_MAX•For C, it is defined in stdlib.h•arc4random() is a function available in some operating systems (primarily BSD-based systems like macOS and FreeBSD) that generates random numbers. It is part of the C standard library and provides a more secure and higher-quality source of random numbers compared to rand()",
      "content_length": 1383,
      "metadata": {
        "collection_name": "batch_1763296567",
        "slide_number": 9,
        "document_type": "pdf",
        "chunk_index": 1,
        "source_file": "Lecture 9_slides.pdf"
      },
      "citation": {
        "source_file": "Lecture 9_slides.pdf",
        "document_type": "pdf",
        "slide_number": 9,
        "collection": "batch_1763296567",
        "formatted": "Slide 9"
      },
      "human_readable_label": "Slide 9"
    }
  ],
  "context": {
    "formatted_content": "[Slide 9]:\nCombining sources of randomness•Suppose r1, r2, …, rkare random numbers from different sources. E.g.,r1 = electrical noise from a resistor or semiconductorr2 = sample of hip-hop music on radior3 = clock on computerb = r1⊕r2⊕…⊕rkIf any one of r1, r2, …, rkis truly random, then so is bMany poor sources + 1 good source = good entropy\n\nPseudorandom Number Generators (PRNGs)•True randomness is expensive•Pseudorandom number generator(PRNGs): An algorithm that uses a little bit of true randomness to generate a lot of random-looking output•Also called deterministic random bit generators(DRBGs)•PRNGs are deterministic: Output is generated according to a set algorithm•However, for an attacker who can’t see the internal state, the output is computationally indistinguishablefrom true randomness\n\nPRNG: Definition•A PRNG has two functions:•PRNG.Seed(randomness): Initializes the internal state using the entropy•Input: Some truly random bits•PRNG.Generate(n): Generate npseudorandom bits•Input: A number s•Output: npseudorandom bits•Updates the internal state as needed•Properties•Correctness: Deterministic•Efficiency: Efficient to generate pseudorandom bits•Security: Indistinguishability from random•Rollback resistance: cannot deduce anything about any previously-generated bit\n\n[Slide 9]:\nPRNGs: Summary•True randomness requires sampling a physical process•PRNG: An algorithm that uses a little bit of true randomness to generate a lot of random-looking output•Seed(entropy): Initialize internal state•Generate(n): Generate n bits of pseudorandom output•Security: computationally indistinguishable from truly random bits\n\nStream Ciphers\n\nStream Ciphers•process the message bit by bit (as a stream) •typically have a (pseudo) random stream key•combined (XOR) with plaintext bit by bit •randomness of stream keycompletely destroysany statistically properties in the message •Ci= MiXOR StreamKeyi•what could be simpler!!!! •but must never reuse stream key•otherwise, can remove effect and recover messages, M⨁K⨁K = M\n\nStream Cipher Properties•some design considerations are:•statistically random •depends on large enough key•large linear complexity•correlation immunity •confusion•diffusion\n\nHow to generate Stream Key?•How to generate Stream Key?\n\nStream Ciphers •Idea: replace “rand” by “pseudo rand”•Use Pseudo Random Number Generator •A secure PRNG produces output that looks indistinguishable from random•An attacker who can’t see the internal PRNG state can’t learn any output•PRNG: {0,1}s®{0,1}n•expand a short (e.g., 128-bit) random seed into a long (typically unbounded) string that “looks random”•Secret key is the seed•Basic encryption method: Ekey[M] = M ÅPRNG(key)\n\n[Slide 9]:\nExample construction of PRNG•Using block cipher in Counter (CTR) mode:•If you want m random bits, and a block cipher with Ekhas n bits, apply the block cipher m/n times and concatenate the result:•PRNG.Seed(K | IV) = Ek(IV, 1) | Ek(IV, 2) | Ek(IV, 3) … Ek(IV, ceil(m/n)),•| is concatenation•Initialization vector (IV)/Nonce–typically is random or pseudorandom\nRandomness, PRNG output\n\nPRNG: Security•Can we design a PRNG that is truly random?•A PRNG cannot be truly random•The output is deterministic given the initial seed•A secure PRNG is computationally indistinguishable from random to an attacker•Game: Present an attacker with a truly random sequence and a sequence outputted from a secure PRNG•An attacker should be able to determine which is which with probability ≈0•Equivalence: An attacker cannot predict future output of the PRNG\n\nCreate pseudorandom numbers•Truly random numbers are impossible with any program!•However, we can generate seemingly random numbers, called pseudorandom numbers•The function rand() returns a non-negative number between 0 and RAND_MAX•For C, it is defined in stdlib.h•arc4random() is a function available in some operating systems (primarily BSD-based systems like macOS and FreeBSD) that generates random numbers. It is part of the C standard library and provides a more secure and higher-quality source of random numbers compared to rand()",
    "content_length": 4084,
    "word_count": 551,
    "truncated": false
  },
  "citations": {
    "total_count": 1,
    "all_citations": [
      {
        "source_file": "Lecture 9_slides.pdf",
        "document_type": "pdf",
        "slide_number": 9,
        "collection": "batch_1763296567",
        "formatted": "Slide 9"
      }
    ],
    "chunk_citations": [
      {
        "chunk_number": 1,
        "citation": {
          "source_file": "Lecture 9_slides.pdf",
          "document_type": "pdf",
          "slide_number": 9,
          "collection": "batch_1763296567",
          "formatted": "Slide 9"
        },
        "distance": null
      },
      {
        "chunk_number": 2,
        "citation": {
          "source_file": "Lecture 9_slides.pdf",
          "document_type": "pdf",
          "slide_number": 9,
          "collection": "batch_1763296567",
          "formatted": "Slide 9"
        },
        "distance": null
      },
      {
        "chunk_number": 3,
        "citation": {
          "source_file": "Lecture 9_slides.pdf",
          "document_type": "pdf",
          "slide_number": 9,
          "collection": "batch_1763296567",
          "formatted": "Slide 9"
        },
        "distance": null
      }
    ]
  }
}