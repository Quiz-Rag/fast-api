{
  "timestamp": "2025-11-16T18:00:22.306027",
  "question": "what is rsa encryption ?",
  "search_query": "RSA encryption what is rsa encryption what is rsa encryption ?",
  "retrieved_documents_count": 3,
  "documents": [
    {
      "chunk_number": 1,
      "content": "Public-Key Cryptography Algorithm(RSA)\n\nRSA Public-key encryption‚Ä¢by Rivest, Shamir & Adleman of MIT in 1977 ‚Ä¢currently the ‚Äúwork horse‚Äù of Internet security‚Ä¢most public key infrastructure (PKI) products‚Ä¢SSL/TLS: certificates and key-exchange‚Ä¢secure e-mail: PGP , Outlook, ‚Ä¶.‚Ä¢based on exponentiation in a finite (Galois) field over integers modulo a prime ‚Ä¢exponentiation takes O((log n)3) operations (easy)‚Ä¢security due to cost of factoring large integer numbers ‚Ä¢factorization takes O(e log n log log n) operations (hard)‚Ä¢uses large integers (eg.1024 bits)\n\nRSA key setup‚Ä¢each user generates a public/private key pair by: ‚Ä¢selecting two large primes at random -p, q‚Ä¢computing their system modulus n=p!q‚Ä¢note √∏(n)=(p-1)(q-1)‚Ä¢selecting at random the encryption key e‚Ä¢where 1<e<√∏(n), gcd(e,√∏(n))=1 ‚Ä¢solve following equation to find decryption key d‚Ä¢ed=1 mod √∏(n)‚Ä¢publish their public encryption key: pk={e,n} ‚Ä¢keep secret private decryption key: sk={d,p,q} \n\n\nRSA key generation‚Ä¢users of RSA must:‚Ä¢determine two primes at random -p, q‚Ä¢select either eor dand compute the other‚Ä¢primes p,qmust not be easily derived from modulus n=p.q‚Ä¢means must be sufficiently large‚Ä¢typically guess and use probabilistic test‚Ä¢exponents e, dare inverses, so use Inverse algorithm to compute the other",
      "content_length": 1280,
      "metadata": {
        "slide_number": 13,
        "collection_name": "batch_1763296567",
        "source_file": "Lecture 13_slides.pdf",
        "chunk_index": 0,
        "document_type": "pdf"
      },
      "citation": {
        "source_file": "Lecture 13_slides.pdf",
        "document_type": "pdf",
        "slide_number": 13,
        "collection": "batch_1763296567",
        "formatted": "Slide 13"
      },
      "human_readable_label": "Slide 13"
    },
    {
      "chunk_number": 2,
      "content": "RSA example1.Select primes: p=17 & q=112.Computen = pq=17√ó11=1873.Compute√∏(n)=(p‚Äì1)(q-1)=16√ó10=1604.Select e: gcd(e,160)=1; choose e=75.Determine d: de=1 mod 160and d < 160Value is d=23since 23√ó7=161= 10√ó160+16.Publish public key pk={7,187}7.Keep secret private key sk={23,17,11}\n\n\nRSA use‚Ä¢to encrypt a message M the sender:‚Ä¢obtains public keyof recipient pk={e,n}‚Ä¢computes: C=Memod n, where 0‚â§M<n‚Ä¢to decrypt the ciphertext C the owner:‚Ä¢uses their private key sk={d,p,q}‚Ä¢computes: M=Cdmod n‚Ä¢note that the message M must be smaller than the modulus n (block if needed)\nPlaintextCiphertextC = ùëÄ!pk={e,n}sk={d,p,q}\n\nExample of RSA algorithm\n\n\nCorrectness of RSA‚Ä¢Euler‚Äôs theorem: if gcd(M, n) = 1, then ùëÄ!(#)=1mod n. Here œÜ(n) is Euler‚Äôs totient function: the number of integers in {1, 2, . . .,n-1} which are relatively prime ton. Whennis a prime, this theorem is just Fermat‚Äôs little theorem\nM‚Äô = ùê∂%mod\tn=ùëÄ&%\tmod n=\tùëÄ(!#)*\tmod n=\t[ùëÄ!(#)](,ùëÄ\tmod\tn= M  mod n",
      "content_length": 954,
      "metadata": {
        "chunk_index": 1,
        "source_file": "Lecture 13_slides.pdf",
        "collection_name": "batch_1763296567",
        "slide_number": 13,
        "document_type": "pdf"
      },
      "citation": {
        "source_file": "Lecture 13_slides.pdf",
        "document_type": "pdf",
        "slide_number": 13,
        "collection": "batch_1763296567",
        "formatted": "Slide 13"
      },
      "human_readable_label": "Slide 13"
    },
    {
      "chunk_number": 3,
      "content": "RSA reading materials‚Ä¢A Method for Obtaining Digital Signatures and Public-Key Cryptosystems\n\nHomomorphic encryption ‚Ä¢Encryption scheme that allows computation on ciphertexts ‚Ä¢an extension of public-key encryption scheme that allows anyone in possession of the public key to perform operations on encrypted data without access to the decryption key‚Ä¢Partially Homomorphic Encryption: Initial public-key systems that allow this for either addition or multiplication, but not both.‚Ä¢i.e. RSA‚Ä¢Fully homomorphic encryption (FHE)\n\nApplication of homomorphic encryption ‚Ä¢One Use case: cloud computing ‚Ä¢A weak computational device Alice (e.g., a mobile phone or a laptop) wishes to perform a computationally heavy task, beyond her computational means. She can delegate it to a much stronger (but still feasible) machine Bob (the cloud, or a supercomputer) who offers the service of doing so. The problem is that Alice does not trust Bob.\nE (Pk, data)E (Pk, f(data))",
      "content_length": 956,
      "metadata": {
        "chunk_index": 1,
        "source_file": "Lecture 14_slides.pdf",
        "collection_name": "batch_1763296567",
        "document_type": "pdf",
        "slide_number": 14
      },
      "citation": {
        "source_file": "Lecture 14_slides.pdf",
        "document_type": "pdf",
        "slide_number": 14,
        "collection": "batch_1763296567",
        "formatted": "Slide 14"
      },
      "human_readable_label": "Slide 14"
    }
  ],
  "context": {
    "formatted_content": "[Slide 13]:\nPublic-Key Cryptography Algorithm(RSA)\n\nRSA Public-key encryption‚Ä¢by Rivest, Shamir & Adleman of MIT in 1977 ‚Ä¢currently the ‚Äúwork horse‚Äù of Internet security‚Ä¢most public key infrastructure (PKI) products‚Ä¢SSL/TLS: certificates and key-exchange‚Ä¢secure e-mail: PGP , Outlook, ‚Ä¶.‚Ä¢based on exponentiation in a finite (Galois) field over integers modulo a prime ‚Ä¢exponentiation takes O((log n)3) operations (easy)‚Ä¢security due to cost of factoring large integer numbers ‚Ä¢factorization takes O(e log n log log n) operations (hard)‚Ä¢uses large integers (eg.1024 bits)\n\nRSA key setup‚Ä¢each user generates a public/private key pair by: ‚Ä¢selecting two large primes at random -p, q‚Ä¢computing their system modulus n=p!q‚Ä¢note √∏(n)=(p-1)(q-1)‚Ä¢selecting at random the encryption key e‚Ä¢where 1<e<√∏(n), gcd(e,√∏(n))=1 ‚Ä¢solve following equation to find decryption key d‚Ä¢ed=1 mod √∏(n)‚Ä¢publish their public encryption key: pk={e,n} ‚Ä¢keep secret private decryption key: sk={d,p,q} \n\n\nRSA key generation‚Ä¢users of RSA must:‚Ä¢determine two primes at random -p, q‚Ä¢select either eor dand compute the other‚Ä¢primes p,qmust not be easily derived from modulus n=p.q‚Ä¢means must be sufficiently large‚Ä¢typically guess and use probabilistic test‚Ä¢exponents e, dare inverses, so use Inverse algorithm to compute the other\n\n[Slide 13]:\nRSA example1.Select primes: p=17 & q=112.Computen = pq=17√ó11=1873.Compute√∏(n)=(p‚Äì1)(q-1)=16√ó10=1604.Select e: gcd(e,160)=1; choose e=75.Determine d: de=1 mod 160and d < 160Value is d=23since 23√ó7=161= 10√ó160+16.Publish public key pk={7,187}7.Keep secret private key sk={23,17,11}\n\n\nRSA use‚Ä¢to encrypt a message M the sender:‚Ä¢obtains public keyof recipient pk={e,n}‚Ä¢computes: C=Memod n, where 0‚â§M<n‚Ä¢to decrypt the ciphertext C the owner:‚Ä¢uses their private key sk={d,p,q}‚Ä¢computes: M=Cdmod n‚Ä¢note that the message M must be smaller than the modulus n (block if needed)\nPlaintextCiphertextC = ùëÄ!pk={e,n}sk={d,p,q}\n\nExample of RSA algorithm\n\n\nCorrectness of RSA‚Ä¢Euler‚Äôs theorem: if gcd(M, n) = 1, then ùëÄ!(#)=1mod n. Here œÜ(n) is Euler‚Äôs totient function: the number of integers in {1, 2, . . .,n-1} which are relatively prime ton. Whennis a prime, this theorem is just Fermat‚Äôs little theorem\nM‚Äô = ùê∂%mod\tn=ùëÄ&%\tmod n=\tùëÄ(!#)*\tmod n=\t[ùëÄ!(#)](,ùëÄ\tmod\tn= M  mod n\n\n[Slide 14]:\nRSA reading materials‚Ä¢A Method for Obtaining Digital Signatures and Public-Key Cryptosystems\n\nHomomorphic encryption ‚Ä¢Encryption scheme that allows computation on ciphertexts ‚Ä¢an extension of public-key encryption scheme that allows anyone in possession of the public key to perform operations on encrypted data without access to the decryption key‚Ä¢Partially Homomorphic Encryption: Initial public-key systems that allow this for either addition or multiplication, but not both.‚Ä¢i.e. RSA‚Ä¢Fully homomorphic encryption (FHE)\n\nApplication of homomorphic encryption ‚Ä¢One Use case: cloud computing ‚Ä¢A weak computational device Alice (e.g., a mobile phone or a laptop) wishes to perform a computationally heavy task, beyond her computational means. She can delegate it to a much stronger (but still feasible) machine Bob (the cloud, or a supercomputer) who offers the service of doing so. The problem is that Alice does not trust Bob.\nE (Pk, data)E (Pk, f(data))",
    "content_length": 3230,
    "word_count": 453,
    "truncated": false
  },
  "citations": {
    "total_count": 2,
    "all_citations": [
      {
        "source_file": "Lecture 13_slides.pdf",
        "document_type": "pdf",
        "slide_number": 13,
        "collection": "batch_1763296567",
        "formatted": "Slide 13"
      },
      {
        "source_file": "Lecture 14_slides.pdf",
        "document_type": "pdf",
        "slide_number": 14,
        "collection": "batch_1763296567",
        "formatted": "Slide 14"
      }
    ],
    "chunk_citations": [
      {
        "chunk_number": 1,
        "citation": {
          "source_file": "Lecture 13_slides.pdf",
          "document_type": "pdf",
          "slide_number": 13,
          "collection": "batch_1763296567",
          "formatted": "Slide 13"
        },
        "distance": null
      },
      {
        "chunk_number": 2,
        "citation": {
          "source_file": "Lecture 13_slides.pdf",
          "document_type": "pdf",
          "slide_number": 13,
          "collection": "batch_1763296567",
          "formatted": "Slide 13"
        },
        "distance": null
      },
      {
        "chunk_number": 3,
        "citation": {
          "source_file": "Lecture 14_slides.pdf",
          "document_type": "pdf",
          "slide_number": 14,
          "collection": "batch_1763296567",
          "formatted": "Slide 14"
        },
        "distance": null
      }
    ]
  }
}